import matplotlib.pyplot as plt
from sunpy.time import TimeRange, parse_time
import sunpy as sp
import pandas as pd
from pandas import DataFrame as df
from radiospectra.sources.callisto import CallistoSpectrogram
from astropy.io import fits
import pandas
from sunpy.time import TimeRange
import pdb
from astropy.table import Table
from sunpy.util import common_base

import configparser
import operator as op
config = configparser.ConfigParser()

ops = {"<": op.lt,
	    "<=": op.le,
        "==": op.eq,
        "=!": op.ne,
        ">=": op.ge,
        ">": op.gt}

def ConfigSectionMap(section):
    dict1 = {}
    options = config.options(section)
    for option in options:
        try:
            dict1[option] = config.get(section, option)
            if dict1[option] == -1:
                DebugPrint("skip: %s" % option)
        except:
            print("exception on %s!" % option)
            dict1[option] = None
    return dict1

#image = CallistoSpectrogram.from_url("http://soleil.i4ds.ch/solarradio/data/2002-20yy_Callisto/2019/01/24/SWISS-BLEN5M_20190124_094500_58.fit.gz")
#image = CallistoSpectrogram.from_url("http://soleil.i4ds.ch/solarradio/data/2002-20yy_Callisto/2010/11/03/BLEN7M_20101103_121505_24.fit.gz")
image = CallistoSpectrogram.from_url("http://soleil.i4ds.ch/solarradio/data/2002-20yy_Callisto/2018/04/01/ALASKA_20180401_150000_59.fit.gz")
#image = CallistoSpectrogram.read(r"C:\Users\David Sommer\Desktop\ALASKA_20180401_150000_59(1).fit.gz")

def create_datearray(series):

    ds = image.header['DATE-OBS']
    de = image.header['DATE-END']
    ts = image.header['TIME-OBS']
    te = image.header['TIME-END']

    Date=[]
    date = str(ds)+" "+str(ts)+" - "+str(de)+" "+str(te)
    Date.append(date)

    return Date


def DF_Success_Lead(x,y,values,time_pos,time_pos_list,last_number,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,pos_num):

    if x != y:

        freq = index_num

        if x == 1:

            Data_As[freq].append(time_pos_list.copy())
            As_Pos[freq].append(pos_num.copy())
            values.clear()
            time_pos_list.clear()
            values.append(last_number)
            time_pos_list.append(time_pos-1)

        elif x == 2:

            Data_Ds[freq].append(time_pos_list.copy())
            Ds_Pos[freq].append(pos_num.copy())
            values.clear()
            time_pos_list.clear()
            values.append(last_number)
            time_pos_list.append(time_pos-1)

        elif x == 3:

            Data_Eq[freq].append(time_pos_list.copy())
            Eq_Pos[freq].append(pos_num.copy())
            values.clear()
            time_pos_list.clear()
            values.append(last_number)
            time_pos_list.append(time_pos-1)


    x = y
    return x,values,time_pos_list,Data_As,Data_Ds, Data_Eq, As_Pos,Ds_Pos ,Eq_Pos

def Rec(series):


    values = []
    time_pos_list = []

    x = 0
    pos_num = 0

    freq = index_num

    Data_As = {}
    Data_As[freq]=[]
    Data_Ds = {}
    Data_Ds[freq]=[]
    Data_Eq = {}
    Data_Eq[freq]=[]

    As_Pos = {}
    As_Pos[freq]=[]
    Ds_Pos = {}
    Ds_Pos[freq]=[]
    Eq_Pos = {}
    Eq_Pos[freq]=[]


    for time_pos, value in series.iteritems():

        if time_pos==0:
            continue

        last_number = series.loc[time_pos-1]
        present_number = series.loc[time_pos]

        if present_number > last_number:
            x,_,_,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,_ = DF_Success_Lead(x,1,values,time_pos,time_pos_list,last_number,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,pos_num)
            values.append(present_number)
            time_pos_list.append(time_pos)

        elif present_number < last_number:
            x,_,_,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,_ = DF_Success_Lead(x,2,values,time_pos,time_pos_list,last_number,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,pos_num)
            values.append(present_number)
            time_pos_list.append(time_pos)

        elif present_number == last_number:
            x,_,_,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,_ = DF_Success_Lead(x,3,values,time_pos,time_pos_list,last_number,Data_As,Data_Ds,Data_Eq,As_Pos,Ds_Pos,Eq_Pos,pos_num)
            values.append(present_number)
            time_pos_list.append(time_pos)

        else:
            print("Value"+ value + "doesn\'t correspond with partner-value.")

    pos_num +=1

    return Data_As, Data_Ds, Data_Eq,As_Pos,Ds_Pos,Eq_Pos


def average_increase(Data_As):

    x = 0
    pos = 0
    freq = index_num

    value_list = []
    Data_As_ath = {}
    Data_As_ath[freq]=[]

    for key_list in Data_As.values():

        for small_list in key_list:

            for time_stamp in small_list:

                value = data.iloc[freq][time_stamp]
                value_list.append(value)

            for value in range(len(value_list)-1):

                first_num = value_list[pos]
                next_num = value_list[pos+1]

                s = next_num - first_num
                t = (small_list[-1] - small_list[0])

                v = s / t
                pos+=1

                mean_As = v / t

                if mean_As >= 2.0:

                    Data_As_ath[freq].append(small_list.copy())


            value_list.clear()

            pos = 0
    return Data_As_ath

def average_decrease(Data_Ds):

    x = 0
    pos = 0
    freq = index_num

    value_list = []
    Data_Ds_ath = {}
    Data_Ds_ath[freq]=[]

    for key_list in Data_Ds.values():

        for small_list in key_list:

            for time_stamp in small_list:

                value = data.iloc[freq][time_stamp]
                value_list.append(value)

            for value in range(len(value_list)-1):

                first_num = value_list[pos]
                next_num = value_list[pos+1]

                s = next_num - first_num
                t = (small_list[-1] - small_list[0])

                v = s / t
                pos+=1

                mean_As = v / t

                if mean_As >= 3.0:
                    Data_Ds_ath[freq].append(small_list.copy())
                pos+=1

            value_list.clear()

            pos = 0

            x+=1


def visualisation(Data_As_ath):

    for key_list in Data_As_ath.values():

        for small_list in key_list:

            for time_stamp in small_list:

                freq = index_num

                value = data.iloc[freq][time_stamp]

                ascending_DataFrame.at[freq, time_stamp] = value

    return ascending_DataFrame

#------------------------------------------------------------
config.read("C:\\Users\\David Sommer\\PycharmProjects\\Rec\\Method")

def equal_range(eq_list):
    op_char = ConfigSectionMap("Method_1")["eq_len_op"]
    op_func = ops[op_char]

    eq_r = ConfigSectionMap("Method_1")["eq_parameter"]
    if ops[op_func](len(eq_list),eq_r):
        allowed_range = True
    return allowed_range

def global_mean(data):
    mean_sum = 0
    for index_num,row in data.iterrows():
        row_mean = row.mean()
        mean_sum += row_mean

    g_mean = mean_sum / index_num
    return g_mean

def leveled_value_bridge(As_Pos,Ds_Pos,Eq_Pos,Data_Eq):

    freq = index_num

    positional_arg = []

    Data_Eq_ev = {}
    Data_Eq_ev[freq]=[]

    for timestamp_list in Eq_Pos.values():

        for timestamp in timestamp_list:

            previous_number = timestamp - 1
            following_num = timestamp + 1

            if previous_number in As_Pos:
                positional_arg.append("A")

            elif previous_number in Ds_Pos:
                positional_arg.append("D")

            if following_num in As_Pos:
                positional_arg.append("A")

            elif following_num in Ds_Pos:
                positional_arg.append("D")

                pos_a = ConfigSectionMap("Method_1")["positional_argrument"]
                if positional_arg == pos_a:
                    bridge_orientation = True

            positional_arg.clear()

            dict_pos = timestamp_list.index(timestamp)
            Eq_list = Data_Eq.index(dict_pos)

            allowed_range = equal_range(Eq_list)


        #Data_Eq_ev[freq].append(Eq_list.copy())

#-----------------------------------------------------------

    return

data = df(image.data)
ascending_DataFrame = pd.DataFrame(data=0,index=range(200),columns=range(3600))
for index_num,row in data.iterrows():
    series = data.loc[index_num]

    Data_As, Data_Ds = Rec(series)

    Data_As_ath = average_increase(Data_As)

    ascending_DataFrame = visualisation(Data_As_ath)
print(ascending_DataFrame.at[90,55])
print(ascending_DataFrame)
r = ascending_DataFrame.as_matrix()
image_conv = image._with_data(r)

image_conv.peek()
